<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>업무보고 자동검증기</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/codemirror@5.65.13/lib/codemirror.css" />
    <style>
      body { background: linear-gradient(120deg, #e8edff 0%, #f7f7fa 100%); font-family: "Segoe UI", "Apple SD Gothic Neo", "Malgun Gothic", sans-serif; margin: 0; min-height: 100vh; }
      .container { max-width: 850px; margin: 48px auto; background: #fff; border-radius: 22px; box-shadow: 0 6px 32px #5165ff20, 0 2px 8px #0001; padding: 36px 30px 30px 30px; transition: box-shadow 0.2s; border: 1.5px solid #e6e8f0; }
      h2 { text-align: left; font-weight: 700; font-size: 1.4rem; margin-bottom: 26px; color: #3049ff; letter-spacing: -1px; }
      .CodeMirror { border-radius: 13px; border: 1.5px solid #b5c6fa; box-shadow: 0 2px 8px #3049ff0d; background: #fafdff; font-size: 1.07rem; line-height: 1.75; min-height: 220px; width: 100%; margin-bottom: 22px; transition: border 0.16s; }
      .CodeMirror-focused { border: 1.8px solid #3654ff; background: #f4f8ff; outline: none; }
      button { width: 100%; margin: 10px 0 0 0; font-size: 1.18rem; font-weight: 600; background: linear-gradient(90deg, #3654ff 75%, #1c97e7 100%); color: #fff; border: none; border-radius: 8px; padding: 12px 0; cursor: pointer; box-shadow: 0 2px 12px #3654ff24; transition: background 0.14s, box-shadow 0.17s, transform 0.14s; letter-spacing: 0.2px; }
      button:hover, button:focus { background: linear-gradient(90deg, #1c97e7 70%, #3654ff 100%); box-shadow: 0 3px 20px #1c97e74c; transform: translateY(-1px) scale(1.01); }
      .result { margin-top: 30px; min-height: 46px; animation: fadein 0.7s; padding: 22px 18px 15px 18px; border-radius: 12px; box-shadow: 0 2px 12px #3049ff10; font-size: 1.07rem; }
      .pass { color: #218938; background: #eaffed; border-left: 6px solid #36d173; font-weight: 700; padding-left: 7px; }
      .fail { color: #e02e2e; background: #fff3f3; border-left: 6px solid #ff5353; font-weight: 700; padding-left: 7px; }
      ul { line-height: 1.78; margin-top: 10px; margin-bottom: 0; padding-left: 20px; }
      @media (max-width: 1000px) { .container { max-width: 98vw; padding: 18px 3vw 30px 3vw; } }
      @keyframes fadein { 0% { opacity: 0; transform: translateY(12px);} 80% { opacity: 0.7;} 100% { opacity: 1; transform: translateY(0);} }
    </style>
  </head>
  <body>
    <div class="container">
      <h2>업무보고 자동검증기</h2>
      <textarea id="code" name="code">여기에 붙여넣으세요</textarea>
      <button id="checkBtn">검증</button>
      <div id="result" class="result"></div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.13/lib/codemirror.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.13/mode/markdown/markdown.js"></script>
    <script>
      // CodeMirror 에디터 세팅
      var editor = CodeMirror.fromTextArea(document.getElementById("code"), {
        lineNumbers: true,
        mode: "markdown",
        lineWrapping: true,
      });

      // ▶️ 포커스 시 플레이스홀더 자동 삭제
      let clearedPlaceholder = false;
      editor.on("focus", function () {
        if (!clearedPlaceholder && editor.getValue().trim() === "여기에 붙여넣으세요") {
          editor.setValue("");
          clearedPlaceholder = true;
        }
      });

      function checkReportFormatting(text) {
        const lines = text.replace(/\r\n/g, "\n").split("\n");
        let errors = [];

        // 날짜 표기 금지 패턴들
        const forbiddenZeroOrUntilDate =
          /\(\~?((0\d{1}|[1-9]|1[0-2]))\/((0\d{1}|[1-9]|[12][0-9]|3[01]))(\s*까지)?\)/g;

        // 날짜 표기 검증
        for (let i = 0; i < lines.length; i++) {
          let line = lines[i];
          let matches = line.match(forbiddenZeroOrUntilDate);
          if (matches) {
            for (let m of matches) {
              const dateContent = m.replace(/[()~]/g, "").replace(/\s/g, "");
              const [month, rest] = dateContent.split("/");
              const untilIncluded = m.includes("까지");
              if (
                (month.length === 2 && month.startsWith("0")) || // 월 0시작
                (rest.length > 1 && rest.startsWith("0")) || // 일 0시작
                untilIncluded
              ) {
                errors.push(
                  `[${i + 1}행] 허용되지 않는 날짜 표기: ${m} (날짜는 (8/23), (~7/30) 형태만 허용, 월/일 0으로 시작·"까지" 포함은 금지)`
                );
              }
            }
          }
        }

        function getLine(idx, offset) {
          return lines[idx + offset] !== undefined ? lines[idx + offset] : "";
        }
        function isBlank(line) {
          return line.trim() === "";
        }
        function isMid(line) {
          return /^ *- /.test(line);
        }
        function isLow(line) {
          return /^ *․/.test(line);
        }
        function isSection(line) {
          return /^(\d+\.\s|\(\d+\))/.test(line);
        }
        function isMonth(line) {
          return /^\[[가-힣]+\]$/.test(line);
        }
        function isSeparator(line) {
          return /^-{5,}$/.test(line);
        }
        function nextNonBlank(idx) {
          let i = idx + 1;
          while (i < lines.length && isBlank(lines[i])) i++;
          return { line: lines[i] || "", idx: i };
        }

        // 소분류(․) 묶음 탐색 시 빈줄도 포함하여 묶음 처리
        let i = 0;
        while (i < lines.length) {
          const line = lines[i];
          if (isMid(line)) {
            // 중분류 상태 추출
            const midStateMatch = line.match(
              /(.+)\((완료|진행중|보류|취소|~?\d{1,2}\/\d{1,2})\)$/
            );
            const midState = midStateMatch ? midStateMatch[2] : null;

            // 연속된 소분류(․) 블록 탐색 (중간에 빈 줄 허용)
            let lowList = [];
            let j = i + 1;
            while (j < lines.length && (isLow(lines[j]) || isBlank(lines[j]))) {
              if (isLow(lines[j])) {
                let m = lines[j].match(
                  /(.+)\((완료|진행중|보류|취소|~?\d{1,2}\/\d{1,2})\)$/
                );
                let state = m ? m[2] : null;
                lowList.push({ idx: j, state });
              }
              j++;
            }

            if (lowList.length > 1) {
              const allStates = lowList.map((x) => x.state);
              const uniqueStates = [...new Set(allStates.filter(Boolean))];
              if (
                uniqueStates.length === 1 &&
                uniqueStates[0] !== null &&
                allStates.every((x) => x)
              ) {
                for (const low of lowList) {
                  if (low.state) {
                    errors.push(
                      `[${low.idx + 1}행] 소분류가 모두 같은 상태(${
                        uniqueStates[0]
                      })일 때는, 소분류에는 상태를 입력하지 마시고 중분류에만 상태를 입력하세요.`
                    );
                  }
                }
              }
            }
            i = j;
            continue;
          }
          i++;
        }

        // [룰변경] 줄바꿈/공백 체크 + 괄호, 대괄호, :, >, + 룰 추가
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];

          if (!isBlank(line)) {
            if (/^\s{2,}/.test(line))
              errors.push(
                `[${i + 1}행] 들여쓰기는 1칸 이상 금지(불필요한 앞공백).`
              );
          }

          // ( ) 또는 [ ] 대괄호/괄호 양쪽 공백 체크: 단, 중대분류(1), (2)는 예외
          if (!isSection(line) && /( \(|\(\s| \)|\)\s|\[ |\[\s| \]|\]\s)/.test(line)) {
            errors.push(
              `[${i + 1}행] ( ) 또는 [ ] 괄호/대괄호 양쪽에 공백이 있으면 안 됩니다.`
            );
          }

          // > 또는 : 기호 앞뒤 공백 체크
          if (/( [>:])|([>:] )/.test(line)) {
            errors.push(
              `[${i + 1}행] '>', ':' 기호의 앞뒤에 공백이 있으면 안 됩니다.`
            );
          }

          // + 기호 앞뒤 공백 체크: 반드시 앞뒤로 한 칸 있어야 함
          if (/\S\+\S/.test(line) || /\+\+/.test(line)) {
            errors.push(
              `[${i + 1}행] '+' 기호는 반드시 앞뒤로 공백이 1칸씩 있어야 합니다.`
            );
          }
          // 만약 +가 있는데 앞뒤로 공백이 아니면 에러
          if (/\+/.test(line)) {
            if (!/ (\+) /.test(line) && !/(^|\s)\+(\s|$)/.test(line)) {
              errors.push(
                `[${i + 1}행] '+' 기호는 반드시 앞뒤로 공백이 1칸씩 있어야 합니다.`
              );
            }
          }

          // 상태표기 괄호 앞뒤 공백 체크 (중분류/소분류)
          if (isMid(line) || isLow(line)) {
            if (/(\s\(|\(\s| \)|\)\s)/.test(line)) {
              errors.push(`[${i + 1}행] 괄호 ( 또는 ) 양쪽에 공백이 있으면 안 됩니다.`);
            }
          }

          if (isSeparator(line)) {
            if (
              !(
                isBlank(getLine(i, -1)) &&
                isBlank(getLine(i, -2)) &&
                isBlank(getLine(i, -3)) &&
                !isBlank(getLine(i, -4))
              )
            ) {
              errors.push(
                `[${i + 1}행] 구분선(------) 위에는 반드시 줄바꿈 3줄만 있어야 합니다.`
              );
            }
            if (!(isBlank(getLine(i, +1)) && !isBlank(getLine(i, +2)))) {
              errors.push(
                `[${i + 1}행] 구분선(------) 아래에는 반드시 줄바꿈 1줄만 있어야 합니다.`
              );
            }
          }
        }

        // 분류 표기 뒤에 반드시 공백 1칸만 허용
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];
          // 대분류: 1. 또는 2. 등
          if (/^([1-9]\d*)\. ?/.test(line)) {
            const m = line.match(/^([1-9]\d*)\.(\s*)/);
            if (!m || m[2].length !== 1) {
              errors.push(`[${i + 1}행] 대분류(1. 2. 등) 뒤에는 반드시 공백 1칸만 있어야 합니다.`);
            }
          }
          // 대중분류: (1) (2) 등
          if (/^\(\d+\)\s*/.test(line)) {
            const m = line.match(/^\(\d+\)(\s*)/);
            if (!m || m[1].length !== 1) {
              errors.push(`[${i + 1}행] 대중분류((1) (2) 등) 뒤에는 반드시 공백 1칸만 있어야 합니다.`);
            }
          }
          // 중분류: - 내용
          if (/^-/.test(line) && !/^- /.test(line)) {
            errors.push(`[${i + 1}행] 중분류(-) 뒤에는 반드시 공백 1칸이어야 합니다.`);
          }
          // 소분류: ․ 내용
          if (/^․/.test(line) && !/^․ /.test(line)) {
            errors.push(`[${i + 1}행] 소분류(․) 뒤에는 반드시 공백 1칸이어야 합니다.`);
          }
          // [NEW] 온점(.) 시작 에러
          if (/^\./.test(line)) {
            errors.push(`[${i + 1}행] 소분류는 반드시 '․'로 시작해야 하며, '.'(온점)으로 시작하면 안 됩니다.`);
          }
          // 중/소분류 뒤에 공백 2칸 이상도 체크
          if (/^-  /.test(line) || /^․  /.test(line)) {
            errors.push(`[${i + 1}행] 중/소분류 뒤에는 반드시 공백 1칸만 허용합니다.`);
          }
        }
        return errors;
      }

      document.getElementById("checkBtn").onclick = function () {
        const input = editor.getValue();
        const resultDiv = document.getElementById("result");
        const errors = checkReportFormatting(input);

        if (errors.length === 0) {
          resultDiv.innerHTML = `<div class="pass">✅ 모든 항목이 규칙에 맞습니다. </div>`;
        } else {
          resultDiv.innerHTML =
            `<div class="fail">❌ ${errors.length}건의 오류가 발견되었습니다.<br><ul><li>` +
            errors.join("</li><li>") +
            "</li></ul></div>";
        }
      };
    </script>
  </body>
</html>
